(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{446:function(v,_,l){"use strict";l.r(_);var i=l(1),t=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"jvm内存结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存结构"}},[v._v("#")]),v._v(" JVM内存结构")]),v._v(" "),_("ul",[_("li",[v._v("线程私有：程序计数器、虚拟机栈、本地方法区")]),v._v(" "),_("li",[v._v("线程共享：堆、方法区，对外内存（1.7永久代，1.8元空间）")])]),v._v(" "),_("p",[_("strong",[v._v("栈是运行时的单位，而堆是存储的单位")])]),v._v(" "),_("p",[v._v("栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪")]),v._v(" "),_("h4",{attrs:{id:"程序计数器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[v._v("#")]),v._v(" 程序计数器")]),v._v(" "),_("p",[v._v("PC寄存器用于存储指定下一条指令的地址")]),v._v(" "),_("h4",{attrs:{id:"虚拟机栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[v._v("#")]),v._v(" 虚拟机栈")]),v._v(" "),_("p",[v._v("主管Java程序的运行，保存方法的局部变量、部分结果，并参与方法的调用与返回")]),v._v(" "),_("h5",{attrs:{id:"栈帧的内部结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈帧的内部结构"}},[v._v("#")]),v._v(" 栈帧的内部结构")]),v._v(" "),_("ul",[_("li",[v._v("局部变量表\n"),_("ul",[_("li",[v._v("是一组变量值存储空间\n"),_("ul",[_("li",[v._v("最基本的存储单元为"),_("strong",[v._v("slot（槽）")]),v._v("，32位以内的类型占一个slot，64位占连续2个slot")]),v._v(" "),_("li",[v._v("JVM会为每个slot分配一个"),_("strong",[v._v("访问索引")])]),v._v(" "),_("li",[v._v("当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会"),_("strong",[v._v("按照顺序被复制")]),v._v("到局部变量表中的每一个 Slot 上")]),v._v(" "),_("li",[_("strong",[v._v("如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可")])]),v._v(" "),_("li",[v._v("如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处")]),v._v(" "),_("li",[_("strong",[v._v("栈帧中的局部变量表中的槽位是可以重用的")])])])]),v._v(" "),_("li",[v._v("线程私有")]),v._v(" "),_("li",[v._v("所需的容量大小编译器已经确定下来")]),v._v(" "),_("li",[v._v("局部变量表中的变量只能当前方法中使用")])])]),v._v(" "),_("li",[v._v("操作数栈\n"),_("ul",[_("li",[_("strong",[v._v("主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间")])]),v._v(" "),_("li",[_("strong",[v._v("如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中")]),v._v("，并更新 PC 寄存器中下一条需要执行的字节码指令")]),v._v(" "),_("li",[v._v("栈顶缓存："),_("strong",[v._v("栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率")])])])]),v._v(" "),_("li",[v._v("动态链接：指向运行时常量池的方法引用\n"),_("ul",[_("li",[v._v("JVM加载class文件时，所有的变量和方法引用都为**"),_("code",[v._v("符号引用")]),v._v("**保存在class文件常量池中")]),v._v(" "),_("li",[v._v("动态链接的作用就是将这些符号引用转为"),_("strong",[v._v("调用方法的直接引用")])])])]),v._v(" "),_("li",[v._v("方法返回地址：方法正常或异常退出的地址")])]),v._v(" "),_("h4",{attrs:{id:"本地方法栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[v._v("#")]),v._v(" 本地方法栈")]),v._v(" "),_("ul",[_("li",[v._v("本地方法接口\n"),_("ul",[_("li",[v._v("Native Method")])])]),v._v(" "),_("li",[v._v("本地方法栈\n"),_("ul",[_("li",[v._v("用于管理本地方法的调用")])])])]),v._v(" "),_("h4",{attrs:{id:"堆内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆内存"}},[v._v("#")]),v._v(" 堆内存")]),v._v(" "),_("ul",[_("li",[v._v("内存划分\n"),_("ul",[_("li",[v._v("新生代\n"),_("ul",[_("li",[v._v("伊甸园区:幸存者S0:幸存者S1默认8:1:1")]),v._v(" "),_("li",[v._v("GC 15次仍未被回收则进入老年代")])])]),v._v(" "),_("li",[v._v("老年代")]),v._v(" "),_("li",[v._v("元空间")])])]),v._v(" "),_("li",[v._v("设置堆内存大小和OOM\n"),_("ul",[_("li",[_("code",[v._v("-Xms")]),v._v(" 用来表示堆的起始内存，等价于 "),_("code",[v._v("-XX:InitialHeapSize")]),v._v("，默认电脑内存大小1/64")]),v._v(" "),_("li",[_("code",[v._v("-Xmx")]),v._v(" 用来表示堆的最大内存，等价于 "),_("code",[v._v("-XX:MaxHeapSize")]),v._v("，默认电脑内存大小1/4")]),v._v(" "),_("li",[v._v("通常会将 "),_("code",[v._v("-Xmx")]),v._v(" 和 "),_("code",[v._v("-Xms")]),v._v(" 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能")])])]),v._v(" "),_("li",[v._v("对象在堆中的生命周期\n"),_("ul",[_("li",[v._v("当创建一个新对象，对象会被优先分配到新生代的Eden区\n"),_("ul",[_("li",[v._v("此时JVM会给对象定义一个"),_("code",[v._v("对象年轻计数器")]),v._v("（"),_("code",[v._v("-XX:MaxTenuringThreshold")]),v._v("）")])])]),v._v(" "),_("li",[v._v("当Eden区空间不足时，JVM会进行新生代的垃圾回收（Minor GC）\n"),_("ul",[_("li",[v._v("JVM会将存活的对象转移到Survivor中，对象年龄+1")]),v._v(" "),_("li",[v._v("对象在Survivor区中一样需要经历GC，每次年龄+1")]),v._v(" "),_("li",[v._v("对象会在Survivor0区和Survivor1区来回倒腾\n"),_("ul",[_("li",[v._v("如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区")]),v._v(" "),_("li",[v._v("如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区")])])])])]),v._v(" "),_("li",[v._v("如果对象年龄超过设置的"),_("code",[v._v("-XX:MaxTenuringThreshold")]),v._v("，默认15次，对象会被直接分配到老年代")])])]),v._v(" "),_("li",[v._v("GC垃圾回收\n"),_("ul",[_("li",[v._v("Minor GC")]),v._v(" "),_("li",[v._v("Major GC")]),v._v(" "),_("li",[v._v("Full GC")])])]),v._v(" "),_("li",[v._v("逃逸分析\n"),_("ul",[_("li",[v._v("当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸")]),v._v(" "),_("li",[v._v("当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸\n"),_("ul",[_("li",[v._v("例如：return一个对象，虽然是一个局部变量，但是其逃逸到了方法外部，有可能被其他线程访问到")])])])])])]),v._v(" "),_("h4",{attrs:{id:"方法区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[v._v("#")]),v._v(" 方法区")]),v._v(" "),_("p",[v._v("存储类信息、常量池、静态变量、JIT编译后的代码等数据，属于线程共享的内存区域")])])}),[],!1,null,null,null);_.default=t.exports}}]);