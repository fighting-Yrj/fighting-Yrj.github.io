(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{447:function(v,_,l){"use strict";l.r(_);var i=l(1),a=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"判断一个对象是否能被回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#判断一个对象是否能被回收"}},[v._v("#")]),v._v(" 判断一个对象是否能被回收")]),v._v(" "),_("ul",[_("li",[v._v("引用计数法\n"),_("ul",[_("li",[v._v("当对象增加一个引用时，计数器+1；当计数器为0时，代表可被回收")]),v._v(" "),_("li",[v._v("缺点：两个对象出现循环，导致计数器一只不为0")])])]),v._v(" "),_("li",[v._v("可达性分析\n"),_("ul",[_("li",[v._v("通过GC Roots作为起始点搜索，能够达到的对象都是存活的，不可达的对象可被回收")])])]),v._v(" "),_("li",[v._v("方法区回收")]),v._v(" "),_("li",[v._v("finalize()")])]),v._v(" "),_("h3",{attrs:{id:"引用类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用类型"}},[v._v("#")]),v._v(" 引用类型")]),v._v(" "),_("ul",[_("li",[v._v("强引用")]),v._v(" "),_("li",[v._v("弱引用")]),v._v(" "),_("li",[v._v("软引用")]),v._v(" "),_("li",[v._v("虚引用")])]),v._v(" "),_("h3",{attrs:{id:"垃圾回收算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[v._v("#")]),v._v(" 垃圾回收算法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("标记-清除")]),v._v(" "),_("ul",[_("li",[v._v("将存活的对象进行标记，然后清理掉未被标记的对象")]),v._v(" "),_("li",[v._v("不足：会有大量的空间碎片，导致大对象分配不到空间")])])]),v._v(" "),_("li",[_("p",[v._v("标记-整理")]),v._v(" "),_("ul",[_("li",[v._v("让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存")])])]),v._v(" "),_("li",[_("p",[v._v("复制")]),v._v(" "),_("ul",[_("li",[v._v("将内存划分为大小相等的两块，每次只使用其中一块")]),v._v(" "),_("li",[v._v("当这一块内存用完了就将还存活的对象复制到另一块上面")]),v._v(" "),_("li",[v._v("再把使用过的内存空间进行一次清理")]),v._v(" "),_("li",[v._v("缺点：只能使用一半的内容空间")])])]),v._v(" "),_("li",[_("p",[v._v("分代收集")]),v._v(" "),_("ul",[_("li",[v._v("新生代使用：复制算法")]),v._v(" "),_("li",[v._v("老年代使用："),_("code",[v._v("标记-清除")]),v._v("或"),_("code",[v._v("标记-整理")]),v._v("算法")])])])]),v._v(" "),_("h3",{attrs:{id:"垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[v._v("#")]),v._v(" 垃圾收集器")]),v._v(" "),_("ul",[_("li",[v._v("Serial 收集器\n"),_("ul",[_("li",[v._v("串行")]),v._v(" "),_("li",[v._v("单线程收集器")])])]),v._v(" "),_("li",[v._v("Serial Old 收集器\n"),_("ul",[_("li",[v._v("Serial 收集器老年代版本")])])]),v._v(" "),_("li",[v._v("ParNew 收集器\n"),_("ul",[_("li",[v._v("Serial收集器多线程版本")])])]),v._v(" "),_("li",[v._v("Parallel Scavenge 收集器\n"),_("ul",[_("li",[v._v("与 ParNew 一样是多线程收集器")]),v._v(" "),_("li",[v._v("区别在于它是一个"),_("code",[v._v("吞吐量优先")]),v._v("收集器")])])]),v._v(" "),_("li",[v._v("Parallel Old 收集器\n"),_("ul",[_("li",[v._v("是 Parallel Scavenge 收集器的老年代版本")])])]),v._v(" "),_("li",[v._v("CMS 收集器")]),v._v(" "),_("li",[v._v("G1 收集器")])])])}),[],!1,null,null,null);_.default=a.exports}}]);