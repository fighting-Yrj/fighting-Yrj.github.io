(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{442:function(t,r,a){"use strict";a.r(r);var s=a(1),e=Object(s.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"arraylist"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[t._v("#")]),t._v(" ArrayList")]),t._v(" "),r("h4",{attrs:{id:"底层实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#底层实现"}},[t._v("#")]),t._v(" 底层实现")]),t._v(" "),r("p",[t._v("ArrayList底层通过"),r("strong",[t._v("数组实现")]),t._v("，每个ArrayList都有一个"),r("strong",[t._v("容量(capacity)")]),t._v("，可以预知大小的情况下预先给定一个"),r("code",[t._v("capacity")]),t._v("，这样可以减少扩容带来的资源消耗。")]),t._v(" "),r("h4",{attrs:{id:"自动扩容"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自动扩容"}},[t._v("#")]),t._v(" 自动扩容")]),t._v(" "),r("p",[t._v("每当向数组添加元素时，都会先判断添加元素后的个数是否大于数组长度，如果大于的话就会触发扩容"),r("code",[t._v("ensureCapacity(int minCapacity)")]),t._v("。数组在扩容时，会将老数组的元素"),r("strong",[t._v("拷贝一份到新数组中")]),t._v("，每次扩容的大约是原来的"),r("strong",[t._v("1.5倍")])]),t._v(" "),r("h3",{attrs:{id:"linkedlist"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[t._v("#")]),t._v(" LinkedList")]),t._v(" "),r("p",[t._v("LinkedList底层是通过"),r("strong",[t._v("双向链表")]),t._v("实现的；LinkedList同时实现了"),r("strong",[t._v("list接口")]),t._v("和"),r("strong",[t._v("Deque接口")]),t._v("，所以它可以看作一个"),r("strong",[t._v("顺序容器")]),t._v("，也可以是"),r("strong",[t._v("队列(queue)")]),t._v("，同时又可以是一个"),r("strong",[t._v("栈(stack)")]),t._v("。关于栈或队列，现在首选**"),r("code",[t._v("ArrayDeque")]),t._v("**")]),t._v(" "),r("h3",{attrs:{id:"priorityqueue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#priorityqueue"}},[t._v("#")]),t._v(" PriorityQueue")]),t._v(" "),r("p",[t._v("PriorityQueue即为优先级队列，作用是能确保每次取出的元素都是"),r("strong",[t._v("队列中权值最小的（最小元素）")]),t._v("。"),r("strong",[t._v("元素大小的评判可以通过元素本身的自然顺序(*natural ordering*)，也可以通过构造时传入的比较器(Comparator)")])]),t._v(" "),r("p",[t._v("Java中PriorityQueue实现了Queue接口，不允许放入"),r("code",[t._v("null")]),t._v("值；其通过堆实现，具体是完全二叉树实现的"),r("strong",[t._v("小顶堆")]),t._v("（"),r("strong",[t._v("即任意一个非叶子节点的权值，都不大于其左右子节点的权值")]),t._v("），即可以通过"),r("strong",[t._v("数组来作为PriorityQueue的底层实现")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/fighting-Yrj/blog-img/main/PriorityQueue_base.png",alt:""}})])])}),[],!1,null,null,null);r.default=e.exports}}]);